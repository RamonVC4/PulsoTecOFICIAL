<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manager - Panel principal</title>
    <link rel="stylesheet" href="../styles/styles_general.css">
    <link rel="stylesheet" href="../styles/styles_manager.css">
</head>
<body>
    <header class="site-header">
        <div class="header-top">
            <div class="container">
                <div class="logo-text">PT</div>
                <h1 class="title">PULSO<span class="gold">TEC</span></h1>
            </div>
        </div>
        <nav class="nav-bar">
            <div class="container">
                <ul class="nav-list">
                    <li><a href="../Index.html">INICIO</a></li>
                    <li><a href="#">TABLERO</a></li>
                    <li><a href="#">AYUDA</a></li>
                    <li class="login"><a href="./login.html">CERRAR SESIÓN</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main class="container manager-main">
        <section class="manager-overview">
            <div class="overview-copy">
                <h2>Panel de coordinación</h2>
                <p class="muted">Controla el flujo entre autores y revisores: asigna proyectos, supervisa el avance de las rúbricas y mantén todo el histórico en un solo lugar.</p>
            </div>
            <!-- FEATURE CREEP \/ -->
            <!-- <div class="overview-metrics">
                <article class="metric-card is-info">
                    <span class="metric-label">Total proyectos</span>
                    <span class="metric-value" data-metric="projects-total">0</span>
                    <p class="metric-sub" data-metric="projects-updated">Actualización: —</p>
                </article>
                <article class="metric-card is-warning">
                    <span class="metric-label">Plazas disponibles</span>
                    <span class="metric-value" data-metric="projects-open">0</span>
                    <p class="metric-sub">Proyectos con menos de 3 revisores asignados</p>
                </article>
                <article class="metric-card is-critical">
                    <span class="metric-label">En revisión activa</span>
                    <span class="metric-value" data-metric="projects-review">0</span>
                    <p class="metric-sub">Programar recordatorios antes de la fecha límite</p>
                </article>
                <article class="metric-card is-success">
                    <span class="metric-label">Rúbricas entregadas</span>
                    <span class="metric-value" data-metric="projects-completed">0</span>
                    <p class="metric-sub">Última rúbrica: —</p>
                </article>
            </div> -->
        </section>

        <section class="manager-dashboard">
            <article class="card projects-card" aria-labelledby="projects-title">
                
                <header class="projects-header">

                    <div class="header-with-button">
                        <div class="projects-header__titles">
                            <h2 id="projects-title">Proyectos recibidos</h2>
                            <p class="muted small">Selecciona un proyecto para administrar su asignación y revisar los detalles.</p>
                        </div>
                        <button class="hide-button" onclick="toggleProjects()">
                            <p>Ocultar</p>
                        </button>
                    </div>


                    <form class="projects-filterbar" id="project-filter-form" autocomplete="off">
                        <div class="filter-field">
                            <label class="filter-label" for="project-search">Buscar</label>
                            <input id="project-search" type="search" placeholder="Título, autor o área…">
                        </div>
                        <div class="filter-field">
                            <label class="filter-label" for="project-filter">Estado</label>
                            <select id="project-filter">
                                <option value="all" selected>Todos</option>
                                <option value="open">Plazas disponibles</option>
                                <option value="full">Asignación completa</option>
                                <option value="review">En revisión</option>
                                <option value="completed">Rúbrica entregada</option>
                            </select>
                        </div>
                    </form>
                </header>
                <ul class="projects-list" id="projects-list" aria-live="polite"></ul>
                <div class="projects-empty" id="projects-empty" hidden>No encontramos proyectos con esos criterios.</div>
                <div class="projects-pagination" id="projects-pagination" hidden>
                    <button type="button" class="btn-pagination" id="projects-prev" aria-label="Proyectos anteriores">Anterior</button>
                    <span class="projects-page-indicator" id="projects-page-indicator">Página 1 de 1</span>
                    <button type="button" class="btn-pagination" id="projects-next" aria-label="Proyectos siguientes">Siguiente</button>
                </div>
            </article>

            <article class="card assignment-card" aria-labelledby="assignment-title">
                <div class="assignment-shell">
                    <div class="assignment-hero">
                        <div class="assignment-head">
                            <h2 id="assignment-title">Selecciona un proyecto</h2>
                            <p class="muted" id="assignment-subtitle">Aquí podrás revisar sus detalles, asignar o reemplazar revisores y consultar la rúbrica.</p>
                        </div>
                        <span class="status-pill" id="assignment-status">—</span>
                    </div>

                    <div class="assignment-placeholder" id="assignment-placeholder">
                        Elige un proyecto del listado para comenzar la gestión.
                    </div>

                    <div class="assignment-content" id="assignment-content" hidden>
                        <div class="assignment-columns">
                            <div class="assignment-column assignment-column--primary">
                                <section class="project-summary" id="project-summary" hidden>
                                    <dl>
                                        <div>
                                            <dt>Autor</dt>
                                            <dd id="summary-author">—</dd>
                                        </div>
                                        <div>
                                            <dt>Área</dt>
                                            <dd id="summary-area">—</dd>
                                        </div>
                                        <div>
                                            <dt>Recibido</dt>
                                            <dd id="summary-submitted">—</dd>
                                        </div>
                                        <div>
                                            <dt>Entrega límite</dt>
                                            <dd id="summary-due">—</dd>
                                        </div>
                                    </dl>
                                </section>

                                <section class="slots-section" id="slots-section" hidden>
                                    <header>
                                        <h3>Revisores asignados</h3>
                                        <p class="muted small">Administra los 3 espacios disponibles. Si un slot está vacío verás el botón “Buscar revisor”.</p>
                                    </header>
                                    <div class="slots-grid" id="slots-grid"></div>
                                    <p class="assignment-note muted small" id="assignment-note" aria-live="polite"></p>
                                </section>

                                <section class="rubric-section" id="rubric-section" hidden>
                                    <header>
                                        <h3>Rúbricas por revisor</h3>
                                        <p class="muted small">Consulta el estado individual y abre cada rúbrica según el revisor.</p>
                                    </header>
                                    <div class="rubric-grid" id="rubric-grid"></div>
                                </section>
                            </div>

                            <div class="assignment-column assignment-column--secondary">
                                <section class="submissions-section" id="submissions-section" hidden>
                                    <header>
                                        <h3>Historial de envíos</h3>
                                    </header>
                                    <div class="submissions-grid" id="submissions-grid"></div>
                                </section>

                                <section class="timeline-section" id="timeline-section" hidden>
                                    <header>
                                        <h3>Movimientos recientes</h3>
                                    </header>
                                    <div class="timeline-wrapper">
                                        <ul class="timeline-list" id="timeline-list"></ul>
                                    </div>
                                </section>

                                <section class="approval-section" id="approval-section" hidden>
                                    <p class="muted small" id="approval-note">Cuando todas las rúbricas estén completas puedes aprobar y cerrar el proyecto.</p>
                                    <button type="button" class="btn-approve" id="approve-btn">Aprobar proyecto</button>
                                </section>
                            </div>
                        </div>
                    </div>
                </div>
            </article>
        </section>


        <!-- QUEREMOS AGREGAR UN HISTORIAL (PARA FUTURO) -->
    </main>


    <!-- script para el historial de proyectos -->
    <script>
    (function () {
        const MAX_REVIEWERS = 3;
        const PAGE_SIZE = 4;
        const locale = 'es-MX';
        const longDate = { day: '2-digit', month: 'long', year: 'numeric' };
        const shortDate = { day: '2-digit', month: 'short', year: 'numeric' };
        const shortDateTime = { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' };

        // Variable global para los revisores
        let reviewers = [];

        async function fetchReviewers() {
            try {
                const response = await fetch('../php/manager_getRevisores.php');
                const data = await response.json();
                if (data.success) {
                    reviewers = data.revisores;
                    console.log("Revisores cargados:", reviewers);
                }
            } catch (error) {
                console.error("Error cargando revisores:", error);
            }
        }

        /*
        const reviewers = [
            { id: 'rev-01', name: 'Dra. Andrea Molina', email: 'andrea.molina@pulso-tec.mx', expertise: ['Biomateriales', 'Ensayos clínicos'] },
            { id: 'rev-02', name: 'Dr. Javier Solís', email: 'javier.solis@pulso-tec.mx', expertise: ['Dispositivos médicos', 'Regulación'] },
            { id: 'rev-03', name: 'Mtra. Luisa Méndez', email: 'luisa.mendez@pulso-tec.mx', expertise: ['Telemedicina', 'Gestión de proyectos'] },
            { id: 'rev-04', name: 'Dra. Karla Hernández', email: 'karla.hernandez@pulso-tec.mx', expertise: ['Farmacología', 'Bioética'] },
            { id: 'rev-05', name: 'Ing. Diego Prado', email: 'diego.prado@pulso-tec.mx', expertise: ['Sensores', 'Analítica de datos'] },
            { id: 'rev-06', name: 'Dr. Salvador Nieto', email: 'salvador.nieto@pulso-tec.mx', expertise: ['Epidemiología', 'Metodología'] }
        ]; */
        // Variable global para guardar los proyectos cargados
        let projects = [];

        async function fetchProjects() {
            try {
                // Llamada al backend
                const response = await fetch('../php/manager_getProyectos.php'); 
                const data = await response.json();

                if (data.success) {
                    // Transformamos los datos 
                    projects = data.proyectos.map(p => {
                        let stageName = p.stage;
                        return {
                            id: p.id, 
                            title: p.title, 
                            author: p.author || 'Autor pendiente', 
                            area: p.area || 'General', 
                            submitted: p.submitted, 
                            due: '2025-12-01', 
                            stage: stageName, 
                            rubric: { status: stageName, score: '—', updated: null },
                            slots: [null, null, null], 
                            entregas: p.entregas,
                            locked: stageName === "Aceptado",
                            timeline: [], 
                            reviews: {}   
                        };
                    });

                    console.log("Proyectos cargados:", projects);
                    
                    // 1. Primero dibujamos la lista
                    renderAll(); 

                    // ejecutamos 'setActiveProject' para que traiga sus detalles de la BD.
                    if (projects.length > 0) {
                        // El 'await' asegura que termine de cargar antes de dejarte interactuar
                        await setActiveProject(projects[0].id);
                    }


                } else {
                    console.error('El servidor respondió con error:', data.message);
                }
            } catch (error) {
                console.error('Error conectando con el backend:', error);
            }
        }
/*
        const projects = [
            {
                id: 'mx-101',
                title: 'Ensayo de biomateriales',
                author: 'Anónimo A',
                area: 'Biomateriales',
                submitted: '2025-11-08',
                due: '2025-11-16',
                stage: 'En revisión',
                status: 'Prioridad alta',
                rubric: { status: 'En progreso', score: '—', updated: '2025-11-09' },
                slots: ['rev-01', 'rev-02', null],
                locked: false,
                submissions: [
                    { label: 'Primer envío', status: 'En revisión', submitted: '2025-11-08', notes: 'Documento original en evaluación.' },
                    { label: 'Segundo envío', status: 'Pendiente', submitted: null, notes: 'Esperando correcciones.' }
                ],
                reviews: {
                    'rev-01': {
                        iterations: [
                            { submission: 1, status: 'Observaciones', score: '7.8', updated: '2025-11-09', summary: 'Adjuntar anexos complementarios.' }
                        ]
                    },
                    'rev-02': {
                        iterations: [
                            { submission: 1, status: 'En progreso', score: '—', updated: '2025-11-09', summary: 'Revisión agendada para 11 nov.' }
                        ]
                    }
                },
                timeline: [
                    { type: 'manager', message: 'Revisión solicitada a Dra. Andrea Molina', at: '2025-11-09T09:15' },
                    { type: 'system', message: 'Documento cargado por el autor', at: '2025-11-08T10:42' }
                ]
            },
            {
                id: 'mx-102',
                title: 'Protocolo anestesia inteligente',
                author: 'Anónimo B',
                area: 'Dispositivos médicos',
                submitted: '2025-11-06',
                due: '2025-11-18',
                stage: 'Sin revisar',
                status: 'Pendiente de asignación',
                rubric: { status: 'Sin iniciar', score: '—', updated: null },
                slots: ['rev-03', null, null],
                locked: false,
                submissions: [
                    { label: 'Primer envío', status: 'Pendiente de revisión', submitted: '2025-11-06', notes: 'Revisión aún no iniciada.' }
                ],
                reviews: {
                    'rev-03': {
                        iterations: [
                            { submission: 1, status: 'Asignado', score: '—', updated: '2025-11-07', summary: 'En espera de revisión.' }
                        ]
                    }
                },
                timeline: [
                    { type: 'system', message: 'Documento cargado por el autor', at: '2025-11-06T08:05' }
                ]
            },
            {
                id: 'mx-090',
                title: 'Guía de monitoreo cardiaco',
                author: 'Anónimo C',
                area: 'Telemedicina',
                submitted: '2025-10-12',
                due: '2025-10-25',
                stage: 'Cerrado',
                status: 'Cerrado',
                rubric: { status: 'Aceptado', score: '9.2', updated: '2025-10-22' },
                slots: ['rev-01', 'rev-02', 'rev-03'],
                locked: true,
                submissions: [
                    { label: 'Primer envío', status: 'En revisión', submitted: '2025-10-12', notes: 'Revisión inicial con observaciones.' },
                    { label: 'Segundo envío', status: 'Aprobado', submitted: '2025-10-20', notes: 'Correcciones incorporadas y aceptadas.' }
                ],
                reviews: {
                    'rev-01': {
                        iterations: [
                            { submission: 1, status: 'Observaciones', score: '8.1', updated: '2025-10-16', summary: 'Clarificar metodología en sección 2.' },
                            { submission: 2, status: 'Aceptado', score: '9.3', updated: '2025-10-22', summary: 'Documento listo para publicación.' }
                        ]
                    },
                    'rev-02': {
                        iterations: [
                            { submission: 2, status: 'Aceptado', score: '9.1', updated: '2025-10-22', summary: 'Revisión complementaria sin observaciones.' }
                        ]
                    },
                    'rev-03': {
                        iterations: [
                            { submission: 2, status: 'Aceptado', score: '9.0', updated: '2025-10-22', summary: 'Revisión final confirmada.' }
                        ]
                    }
                },
                timeline: [
                    { type: 'reviewer', message: 'Rúbrica enviada (aceptado)', at: '2025-10-22T16:10' },
                    { type: 'manager', message: 'Correcciones confirmadas con el autor', at: '2025-10-20T11:34' },
                    { type: 'system', message: 'Proyecto asignado a revisores', at: '2025-10-15T09:18' }
                ]
            },
            {
                id: 'mx-099',
                title: 'Evaluación de algoritmos educativos',
                author: 'Anónimo D',
                area: 'Educación digital',
                submitted: '2025-10-28',
                due: '2025-11-12',
                stage: 'En revisión',
                status: 'En curso',
                rubric: { status: 'Borrador guardado', score: '7.8', updated: '2025-11-05' },
                slots: ['rev-04', 'rev-05', 'rev-06'],
                locked: false,
                submissions: [
                    { label: 'Primer envío', status: 'Con observaciones', submitted: '2025-10-28', notes: 'Borrador con recomendaciones pendientes.' },
                    { label: 'Segundo envío', status: 'Pendiente de autor', submitted: null, notes: 'Esperando respuesta del autor.' }
                ],
                reviews: {
                    'rev-04': {
                        iterations: [
                            { submission: 1, status: 'Observaciones', score: '7.5', updated: '2025-11-03', summary: 'Detallar instrumentos de evaluación.' }
                        ]
                    },
                    'rev-05': {
                        iterations: [
                            { submission: 1, status: 'Borrador guardado', score: '—', updated: '2025-11-05', summary: 'Revisión parcial registrada.' }
                        ]
                    },
                    'rev-06': {
                        iterations: [
                            { submission: 1, status: 'En progreso', score: '—', updated: '2025-11-04', summary: 'Analizando resultados preliminares.' }
                        ]
                    }
                },
                timeline: [
                    { type: 'reviewer', message: 'Rúbrica guardada como borrador', at: '2025-11-05T18:45' },
                    { type: 'manager', message: 'Se agregó a Ing. Diego Prado como revisor', at: '2025-10-30T09:12' }
                ]
            },
            {
                id: 'mx-110',
                title: 'Protocolos de rehabilitación remota',
                author: 'Anónimo E',
                area: 'Telemedicina',
                submitted: '2025-11-02',
                due: '2025-11-20',
                stage: 'En revisión',
                status: 'Seguimiento semanal',
                rubric: { status: 'En progreso', score: '—', updated: '2025-11-12' },
                slots: ['rev-01', null, null],
                locked: false,
                submissions: [
                    { label: 'Primer envío', status: 'En revisión', submitted: '2025-11-02', notes: 'Documentación inicial recibida.' }
                ],
                reviews: {
                    'rev-01': {
                        iterations: [
                            { submission: 1, status: 'En progreso', score: '—', updated: '2025-11-12', summary: 'Se revisan anexos clínicos.' }
                        ]
                    }
                },
                timeline: [
                    { type: 'manager', message: 'Se asignó a Dra. Andrea Molina como revisor principal', at: '2025-11-12T10:25' },
                    { type: 'system', message: 'Proyecto cargado por el autor', at: '2025-11-02T14:40' }
                ]
            },
            {
                id: 'mx-111',
                title: 'Plataforma de diagnósticos con IA',
                author: 'Anónimo F',
                area: 'Inteligencia artificial médica',
                submitted: '2025-11-10',
                due: '2025-11-24',
                stage: 'Sin revisar',
                status: 'Pendiente de asignación',
                rubric: { status: 'Sin iniciar', score: '—', updated: null },
                slots: [null, null, null],
                locked: false,
                submissions: [
                    { label: 'Primer envío', status: 'Pendiente de revisión', submitted: '2025-11-10', notes: 'Esperando asignación de revisores.' }
                ],
                reviews: {},
                timeline: [
                    { type: 'system', message: 'Proyecto recibido en la plataforma', at: '2025-11-10T08:12' }
                ]
            },
            {
                id: 'mx-125',
                title: 'Dispositivo portátil de monitoreo renal',
                author: 'Anónimo G',
                area: 'Dispositivos médicos',
                submitted: '2025-10-30',
                due: '2025-11-22',
                stage: 'En revisión',
                status: 'Observaciones con autor',
                rubric: { status: 'Observaciones', score: '7.5', updated: '2025-11-11' },
                slots: ['rev-02', 'rev-04', null],
                locked: false,
                submissions: [
                    { label: 'Primer envío', status: 'Observaciones enviadas', submitted: '2025-10-30', notes: 'Requiere ajustes en metodología.' },
                    { label: 'Segundo envío', status: 'Pendiente del autor', submitted: null, notes: 'Autor revisando comentarios.' }
                ],
                reviews: {
                    'rev-02': {
                        iterations: [
                            { submission: 1, status: 'Observaciones', score: '7.2', updated: '2025-11-09', summary: 'Clarificar flujo de calibración del sensor.' }
                        ]
                    },
                    'rev-04': {
                        iterations: [
                            { submission: 1, status: 'En progreso', score: '—', updated: '2025-11-11', summary: 'Analizando riesgos farmacológicos asociados.' }
                        ]
                    }
                },
                timeline: [
                    { type: 'reviewer', message: 'Observaciones enviadas por Dr. Javier Solís', at: '2025-11-09T17:05' },
                    { type: 'manager', message: 'Se solicitó actualización al autor', at: '2025-11-11T09:15' }
                ]
            },
            {
                id: 'mx-133',
                title: 'Guía de interacción humano-robot',
                author: 'Anónimo H',
                area: 'Robótica médica',
                submitted: '2025-09-22',
                due: '2025-10-18',
                stage: 'Cerrado',
                status: 'Documentado',
                rubric: { status: 'Aceptado', score: '9.5', updated: '2025-10-16' },
                slots: ['rev-03', 'rev-05', 'rev-06'],
                locked: true,
                submissions: [
                    { label: 'Primer envío', status: 'Aceptado', submitted: '2025-09-22', notes: 'Proyecto aprobado sin observaciones mayores.' }
                ],
                reviews: {
                    'rev-03': {
                        iterations: [
                            { submission: 1, status: 'Aceptado', score: '9.4', updated: '2025-10-16', summary: 'Excelente documentación de la interacción.' }
                        ]
                    },
                    'rev-05': {
                        iterations: [
                            { submission: 1, status: 'Aceptado', score: '9.6', updated: '2025-10-16', summary: 'Resultados consistentes y bien sustentados.' }
                        ]
                    },
                    'rev-06': {
                        iterations: [
                            { submission: 1, status: 'Aceptado', score: '9.5', updated: '2025-10-16', summary: 'Revisión final confirmada.' }
                        ]
                    }
                },
                timeline: [
                    { type: 'manager', message: 'Proyecto cerrado por cumplimiento de rúbricas', at: '2025-10-17T12:20' },
                    { type: 'reviewer', message: 'Rúbrica final registrada por Ing. Diego Prado', at: '2025-10-16T18:32' }
                ]
            }
        ];
        */

        let activeProjectId = null;
        let projectQuery = '';
        let projectFilter = 'all';
        let openSlotIndex = null;
        let projectPage = 0;
        let filteredProjects = [];

        const elements = {
            projectsList: document.getElementById('projects-list'),
            projectsEmpty: document.getElementById('projects-empty'),
            projectsPagination: document.getElementById('projects-pagination'),
            projectsPrev: document.getElementById('projects-prev'),
            projectsNext: document.getElementById('projects-next'),
            projectsPageIndicator: document.getElementById('projects-page-indicator'),
            projectSearch: document.getElementById('project-search'),
            projectFilter: document.getElementById('project-filter'),
            assignmentTitle: document.getElementById('assignment-title'),
            assignmentSubtitle: document.getElementById('assignment-subtitle'),
            assignmentStatus: document.getElementById('assignment-status'),
            assignmentPlaceholder: document.getElementById('assignment-placeholder'),
            assignmentContent: document.getElementById('assignment-content'),
            projectSummary: document.getElementById('project-summary'),
            summaryAuthor: document.getElementById('summary-author'),
            summaryArea: document.getElementById('summary-area'),
            summarySubmitted: document.getElementById('summary-submitted'),
            summaryDue: document.getElementById('summary-due'),
            slotsSection: document.getElementById('slots-section'),
            slotsGrid: document.getElementById('slots-grid'),
            assignmentNote: document.getElementById('assignment-note'),
            rubricSection: document.getElementById('rubric-section'),
            rubricGrid: document.getElementById('rubric-grid'),
            submissionsSection: document.getElementById('submissions-section'),
            submissionsGrid: document.getElementById('submissions-grid'),
            approvalSection: document.getElementById('approval-section'),
            approvalNote: document.getElementById('approval-note'),
            approveBtn: document.getElementById('approve-btn'),
            timelineSection: document.getElementById('timeline-section'),
            timelineList: document.getElementById('timeline-list'),
        };

        function formatDate(value, options = shortDate) {
            if (!value) return '—';
            return new Date(value + (value.includes('T') ? '' : 'T00:00:00')).toLocaleDateString(locale, options);
        }

        function updatePagination(totalPages, totalItems) {
            if (!elements.projectsPagination) return;
            if (!totalItems || totalPages <= 1) {
                elements.projectsPagination.hidden = true;
                return;
            }
            elements.projectsPagination.hidden = false;
            if (elements.projectsPageIndicator) {
                elements.projectsPageIndicator.textContent = `Página ${projectPage + 1} de ${totalPages}`;
            }
            if (elements.projectsPrev) {
                elements.projectsPrev.disabled = projectPage === 0;
            }
            if (elements.projectsNext) {
                elements.projectsNext.disabled = projectPage >= totalPages - 1;
            }
        }

        function formatDateTime(value) {
            if (!value) return '—';
            return new Date(value).toLocaleDateString(locale, shortDateTime);
        }

        function getProject(id) {
            return projects.find(project => project.id === id);
        }

        function getReviewer(id) {
            // Usamos == (doble igual) para que el numero 1 sea igual al texto "1"
            return reviewers.find(reviewer => reviewer.id == id); 
        }

        function statusClass(stage) {
            if (!stage) return '';
            const normalized = stage.toLowerCase();
            if (normalized.includes('prioridad') || normalized.includes('pendiente')) return 'is-critical';
            if (normalized.includes('sin revisar')) return 'is-warning';
            if (normalized.includes('revisión')) return 'is-info';
            if (normalized.includes('finalizado') || normalized.includes('aceptado') || normalized.includes('cerrado')) return 'is-success';
            return 'is-neutral';
        }
/*
        function setActiveProject(id) {
            activeProjectId = id;
            const indexOnList = filteredProjects.findIndex(project => project.id === id);
            if (indexOnList !== -1) {
                projectPage = Math.floor(indexOnList / PAGE_SIZE);
            }
            openSlotIndex = null;
            renderProjects();
            renderAssignment();
        }
*/
            // Variable global para guardar revisores temporales (para que se vean los nombres)
            // Variable global auxiliar
        if (typeof tempReviewers === 'undefined') var tempReviewers = {}; 

        async function setActiveProject(id) {
            activeProjectId = id;
            
            const localProject = filteredProjects.find(p => p.id === id);
            
            // Paginación
            const indexOnList = filteredProjects.findIndex(project => project.id === id);
            if (indexOnList !== -1) {
                projectPage = Math.floor(indexOnList / PAGE_SIZE);
            }
            
            // PEDIR DATOS A PHP
            try {
                const response = await fetch(`../php/manager_getDetalles.php?id=${id}`);
                const data = await response.json();

                if (data.success) {
                    // Limpiamos slots
                    localProject.slots = [null, null, null]; 
                    localProject.reviews = {}; 

                    // Llenamos slots
                    data.interacciones.forEach((interaccion, index) => {
                        if (index < 3) {
                            localProject.slots[index] = interaccion.revisor_id;

                            localProject.reviews[interaccion.revisor_id] = {
                                iterations: [{
                                    submission: 1, 
                                    status: interaccion.terminado ? 'Terminado' : 'En progreso', 
                                    score: '—', 
                                    updated: interaccion.fecha_limite, 
                                    summary: 'Revisor asignado.'
                                }]
                            };
                            
                            // Registramos el nombre para que el HTML lo encuentre
                            addTempReviewer(interaccion);
                        }
                    });
                }
            } catch (error) {
                console.error("Error cargando detalles:", error);
            }

            openSlotIndex = null;
            renderProjects();   
            renderAssignment(); 
        }

        // ESTA FUNCIÓN DEBE ESTAR AFUERA, DISPONIBLE GLOBALMENTE
        // Función auxiliar para registrar revisores que vienen de la BD
        function addTempReviewer(data) {
            if (typeof reviewers === 'undefined') reviewers = [];

            const existing = reviewers.find(r => r.id == data.revisor_id);
            
            if (!existing) {
                // Truco visual: Si no tenemos nombre real, inventamos uno basado en el correo
                // Ejemplo: "andrea.molina@..." -> "Andrea Molina"
                let displayName = data.revisor_email;
                if (data.revisor_email.includes('@')) {
                    const parts = data.revisor_email.split('@')[0].split('.');
                    // Capitalizamos la primera letra de cada parte
                    displayName = parts.map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' ');
                }

                reviewers.push({
                    id: data.revisor_id, 
                    name: displayName, // Ahora mostrará "Andrea Molina" en vez del correo
                    email: data.revisor_email,
                    expertise: ['General'] 
                });
            }
        }

        function renderProjects() {
            filteredProjects = projects
                .filter(project => {
                    const assignedCount = getAssigned(project).length;
                    const hayQuery = project.title.toLowerCase().includes(projectQuery) ||
                        project.author.toLowerCase().includes(projectQuery) ||
                        project.area.toLowerCase().includes(projectQuery);
                    if (!hayQuery) return false;

                    if (projectFilter === 'open') return assignedCount < MAX_REVIEWERS;
                    if (projectFilter === 'full') return assignedCount >= MAX_REVIEWERS;
                    if (projectFilter === 'review') return project.stage.toLowerCase().includes('revisión');
                    if (projectFilter === 'completed') return project.rubric.status.toLowerCase().includes('aceptado') || project.stage.toLowerCase().includes('final');
                    return true;
                })
                .sort((a, b) => new Date(a.due) - new Date(b.due));

            const totalItems = filteredProjects.length;
            const totalPages = totalItems ? Math.ceil(totalItems / PAGE_SIZE) : 1;

            if (totalItems === 0) {
                projectPage = 0;
            } else {
                projectPage = Math.min(projectPage, totalPages - 1);
                projectPage = Math.max(projectPage, 0);
            }

            const start = projectPage * PAGE_SIZE;
            const pageItems = filteredProjects.slice(start, start + PAGE_SIZE);

            elements.projectsList.innerHTML = '';

            pageItems.forEach(project => {
                const assignedCount = getAssigned(project).length;
                const item = document.createElement('li');
                item.className = `project-card ${statusClass(project.stage)}` + (project.id === activeProjectId ? ' is-active' : '');
                item.dataset.id = project.id;
                item.innerHTML = `
                    <header>
                        <h3>${project.title}</h3>
                        <span class="stage-pill">${project.stage}</span>
                    </header>
                    <p class="project-meta">
                        <span>${project.author}</span>
                        <span>Área: ${project.area}</span>
                    </p>
                    <div class="project-footer">
                        <div class="project-dates">
                            <span>Recibido: ${formatDate(project.submitted)}</span>
                            <span>Límite: ${formatDate(project.due)}</span>
                        </div>
                        <div class="project-assignments">
                            <span>${assignedCount}/${MAX_REVIEWERS} revisores</span>
                            <span>${project.rubric.status}</span>
                        </div>
                    </div>
                `;
                item.addEventListener('click', () => setActiveProject(project.id));
                elements.projectsList.appendChild(item);
            });

            elements.projectsEmpty.hidden = totalItems > 0;
            updatePagination(totalPages, totalItems);

            /*
            if (!activeProjectId && totalItems) {
                projectPage = 0;
                activeProjectId = filteredProjects[0].id;
                renderAssignment();
            }*/

            if (totalItems === 0) {
                activeProjectId = null;
                renderAssignment(true);
            }
        }

        function renderAssignment(showPlaceholderOnly = false) {
            if (!activeProjectId || showPlaceholderOnly) {
                elements.assignmentTitle.textContent = 'Selecciona un proyecto';
                elements.assignmentSubtitle.textContent = 'Aquí podrás revisar sus detalles, asignar o reemplazar revisores y consultar la rúbrica.';
                elements.assignmentStatus.textContent = '—';
                elements.assignmentStatus.className = 'status-pill';
                elements.assignmentPlaceholder.hidden = false;
                if (elements.assignmentContent) {
                    elements.assignmentContent.hidden = true;
                }
                elements.projectSummary.hidden = true;
                elements.slotsSection.hidden = true;
                elements.rubricSection.hidden = true;
                elements.submissionsSection.hidden = true;
                elements.approvalSection.hidden = true;
                elements.timelineSection.hidden = true;
                openSlotIndex = null;
                return;
            }

            const project = getProject(activeProjectId);
            elements.assignmentPlaceholder.hidden = true;
            if (elements.assignmentContent) {
                elements.assignmentContent.hidden = false;
            }

            elements.assignmentTitle.textContent = project.title;
            elements.assignmentSubtitle.textContent = `Autor: ${project.author} · Área: ${project.area}`;
            elements.assignmentStatus.textContent = project.stage;
            elements.assignmentStatus.className = `status-pill ${statusClass(project.stage)}`;

            elements.projectSummary.hidden = false;
            elements.summaryAuthor.textContent = project.author;
            elements.summaryArea.textContent = project.area;
            elements.summarySubmitted.textContent = formatDate(project.submitted, longDate);
            elements.summaryDue.textContent = formatDate(project.due, longDate);

            openSlotIndex = null;
            renderSlots(project);
            renderRubricSummary(project);
            renderSubmissions(project);
            renderApproval(project);
            renderTimeline(project);
        }

        function getSlots(project) {
            if (!Array.isArray(project.slots)) {
                project.slots = Array.from({ length: MAX_REVIEWERS }, () => null);
            } else {
                project.slots = Array.from({ length: MAX_REVIEWERS }, (_, index) => project.slots[index] || null);
            }
            return project.slots;
        }

        function getAssigned(project) {
            return getSlots(project).filter(Boolean);
        }

        function ensureReviewEntry(project, reviewerId) {
            if (!project.reviews) {
                project.reviews = {};
            }
            if (!project.reviews[reviewerId]) {
                project.reviews[reviewerId] = {
                    iterations: [
                        { submission: project.submissions?.length || 1, status: 'Asignado', score: '—', updated: new Date().toISOString().slice(0, 10), summary: 'Asignado recientemente.' }
                    ]
                };
            }
        }

        function renderSlots(project) {
            const slots = getSlots(project);
            const locked = !!project.locked;
            const assignedIds = getAssigned(project);
            //const availableReviewers = reviewers.filter(reviewer => !assignedIds.includes(reviewer.id));
            // FILTRO MEJORADO:
            const availableReviewers = reviewers.filter(reviewer => {
                const yaEstaAsignado = assignedIds.some(id => id == reviewer.id);
                return !yaEstaAsignado; 
            });
            elements.slotsSection.hidden = false;
            elements.slotsGrid.innerHTML = '';

            slots.forEach((reviewerId, index) => {
                const reviewer = reviewerId ? getReviewer(reviewerId) : null;
                const isOpen = !locked && !reviewerId && openSlotIndex === index;
                const card = document.createElement('div');
                card.className = 'slot-card' + (reviewerId ? ' is-filled' : ' is-empty');
                if (locked) {
                    card.classList.add('is-disabled');
                }

                if (reviewer) {
                    const rubricEntry = (project.reviews?.[reviewerId]?.iterations || [])
                        .slice()
                        .sort((a, b) => new Date(b.updated || 0) - new Date(a.updated || 0))[0];
                    const statusText = rubricEntry?.status || project.rubric?.status || 'Sin avances';
                    const badgeClass = statusVariant(statusText);
                    const lastUpdated = rubricEntry?.updated || project.rubric?.updated;
                    const score = rubricEntry?.score && rubricEntry.score !== '—' ? rubricEntry.score : (project.rubric?.score || '—');

                    card.innerHTML = `
                        <header>
                            <div class="slot-header-info">
                                <span class="slot-label">Revisor ${index + 1}</span>
                                <strong>${reviewer.name}</strong>
                            </div>
                            ${locked ? '' : `<button type="button" class="slot-remove" data-slot="${index}" aria-label="Liberar a ${reviewer.name}">×</button>`}
                        </header>
                        <div class="slot-meta">
                            <span>${reviewer.email}</span>
                            <span>${reviewer.expertise.join(' · ')}</span>
                        </div>
                        <div class="slot-progress">
                            <span class="submission-status ${badgeClass}">${statusText}</span>
                            <span class="muted tiny">${lastUpdated ? `Actualizado: ${formatDate(lastUpdated, shortDate)}` : 'Sin actualización'}</span>
                            <span class="muted tiny">${score && score !== '—' ? `Puntaje: ${score}` : 'Sin puntaje'}</span>
                        </div>
                        <div class="slot-actions">
                            <button type="button" class="btn-link slot-rubric" data-project="${project.id}" data-reviewer="${reviewerId}">Ver rúbrica</button>
                        </div>
                    `;
                } else {
                    const suggestionsMarkup = isOpen
                        ? `
                            <div class="slot-suggestions">
                                <p class="muted tiny">${availableReviewers.length ? 'Ejemplos sugeridos de revisores disponibles:' : 'No hay revisores disponibles. Libera un espacio o registra nuevos revisores.'}</p>
                                <ul>
                                    ${availableReviewers.map(reviewer => `
                                        <li class="slot-suggestion">
                                            <div>
                                                <strong>${reviewer.name}</strong>
                                                <span class="muted tiny">${reviewer.email}</span>
                                                <span class="muted tiny">${reviewer.expertise.join(' · ')}</span>
                                            </div>
                                            <button type="button" class="btn-secondary slot-assign-btn" data-id="${reviewer.id}" data-slot="${index}">Asignar</button>
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : '';

                    card.innerHTML = locked
                        ? `
                            <header>
                                <div class="slot-header-info">
                                    <span class="slot-label">Revisor ${index + 1}</span>
                                    <strong>Proyecto aprobado</strong>
                                </div>
                            </header>
                            <p class="muted small">No se pueden hacer nuevas asignaciones.</p>
                        `
                        : `
                            <header>
                                <div class="slot-header-info">
                                    <span class="slot-label">Revisor ${index + 1}</span>
                                    <strong>Espacio disponible</strong>
                                </div>
                            </header>
                            <button type="button" class="slot-assign" data-slot="${index}">BUSCAR REVISOR</button>
                            ${suggestionsMarkup}
                        `;
                }

                elements.slotsGrid.appendChild(card);
            });

            const note = elements.assignmentNote;
            if (note && note.dataset.flash !== 'true') {
                if (locked) {
                    note.textContent = 'Proyecto aprobado. La asignación está bloqueada.';
                    note.classList.remove('is-warning');
                } else {
                    const remaining = MAX_REVIEWERS - assignedIds.length;
                    note.textContent = remaining > 0
                        ? `Quedan ${remaining} espacio(s) disponible(s) para asignar revisores.`
                        : 'Asignación completa.';
                    note.classList.remove('is-warning');
                }
            }
            if (note) note.dataset.flash = 'false';

            if (locked) {
                return;
            }

            elements.slotsGrid.querySelectorAll('.slot-assign').forEach(button => {
                button.addEventListener('click', () => {
                    const slotIdx = Number(button.dataset.slot);
                    openSlotIndex = openSlotIndex === slotIdx ? null : slotIdx;
                    renderSlots(project);
                });
            });

            /*
            elements.slotsGrid.querySelectorAll('.slot-assign-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const reviewerId = button.dataset.id;
                    const slotIdx = Number(button.dataset.slot);
                    const slots = getSlots(project);
                    if (slots[slotIdx]) return;
                    if (getAssigned(project).includes(reviewerId)) {
                        showAssignmentNote('Este revisor ya está asignado a otro espacio.', true);
                        return;
                    }
                    slots[slotIdx] = reviewerId;
                    ensureReviewEntry(project, reviewerId);
                    project.timeline.unshift({
                        type: 'manager',
                        message: `Se asignó a ${getReviewer(reviewerId)?.name || 'un revisor'}`,
                        at: new Date().toISOString()
                    });
                    openSlotIndex = null;
                    renderAll();
                    showAssignmentNote(`Asignaste a ${getReviewer(reviewerId)?.name || 'revisor'}.`, false);
                });
            });
            */
            elements.slotsGrid.querySelectorAll('.slot-assign-btn').forEach(button => {
            button.addEventListener('click', async () => { // <--- OJO: ASYNC
                const reviewerId = button.dataset.id;
                const slotIdx = Number(button.dataset.slot);
                
                button.disabled = true;
                button.textContent = "...";

                const payload = {
                    idProyecto: project.id,
                    idRevisor: reviewerId,
                    fechaLimite: '2025-12-31' 
                };

                try {
                    // Enviamos a PHP
                    const res = await fetch('../php/manager_asignarRevisor.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const data = await res.json();

                    if (data.success) {
                        alert("Asignado correctamente");
                        openSlotIndex = null;
                        setActiveProject(project.id); // Recargamos para ver el cambio real
                    } else {
                        alert("Error: " + data.message);
                        button.disabled = false;
                        button.textContent = "Asignar";
                    }
                } catch (error) {
                    console.error(error);
                    alert("Error de conexión");
                    button.disabled = false;
                    button.textContent = "Asignar";
                }
            });
        });
            // --- FIN DE LO NUEVO ---

            elements.slotsGrid.querySelectorAll('.slot-remove').forEach(button => {
                button.addEventListener('click', () => {
                    removeReviewer(project.id, Number(button.dataset.slot));
                });
            });

            elements.slotsGrid.querySelectorAll('.slot-rubric').forEach(button => {
                button.addEventListener('click', () => {
                    const projectId = button.dataset.project;
                    const reviewerId = button.dataset.reviewer;
                    window.location.href = `./review-session.html?doc=${projectId}&reviewer=${reviewerId}`;
                });
            });
        }

        function latestUpdatedFromReviews(project) {
            if (!project.reviews) return null;
            const timestamps = [];
            Object.values(project.reviews).forEach(entry => {
                entry?.iterations?.forEach(iter => {
                    if (iter.updated) timestamps.push(iter.updated);
                });
            });
            if (!timestamps.length) return null;
            return timestamps.sort((a, b) => new Date(b) - new Date(a))[0];
        }

        function statusVariant(statusText = '') {
            const normalized = statusText.toLowerCase();
            if (normalized.includes('acept') || normalized.includes('aprob')) return 'is-success';
            if (normalized.includes('pend') || normalized.includes('progreso')) return 'is-warning';
            if (normalized.includes('observ') || normalized.includes('rechaz') || normalized.includes('error')) return 'is-critical';
            return '';
        }

        function renderRubricSummary(project) {
            const slots = getSlots(project);
            if (!elements.rubricSection || !elements.rubricGrid) {
                return;
            }
            elements.rubricSection.hidden = false;
            elements.rubricGrid.innerHTML = '';

            slots.forEach((reviewerId, index) => {
                const card = document.createElement('article');
                card.className = 'rubric-card';
                const slotLabel = `Revisor ${index + 1}`;

                if (!reviewerId) {
                    card.classList.add('is-empty');
                    card.innerHTML = `
                        <header>
                            <div>
                                <span class="rubric-slot">${slotLabel}</span>
                                <strong>Espacio disponible</strong>
                            </div>
                        </header>
                        <p class="muted small">Asigna un revisor para habilitar su rúbrica individual.</p>
                    `;
                } else {
                    const reviewer = getReviewer(reviewerId);
                    const iterations = (project.reviews?.[reviewerId]?.iterations || [])
                        .slice()
                        .sort((a, b) => (a.submission || 0) - (b.submission || 0));
                    const latest = iterations
                        .slice()
                        .sort((a, b) => new Date(b.updated || 0) - new Date(a.updated || 0))[0];
                    const statusText = latest?.status || project.rubric?.status || 'Sin avances';
                    const badgeClass = statusVariant(statusText);
                    const lastUpdated = latest?.updated || project.rubric?.updated;
                    const score = latest?.score && latest.score !== '—' ? latest.score : (project.rubric?.score || '—');

                    card.innerHTML = `
                        <header>
                            <div>
                                <span class="rubric-slot">${slotLabel}</span>
                                <strong>${reviewer?.name || 'Revisor'}</strong>
                                <span class="muted tiny">${reviewer?.email || ''}</span>
                            </div>
                            <span class="submission-status ${badgeClass}">${statusText}</span>
                        </header>
                        <div class="rubric-body">
                            <p class="muted tiny">${(reviewer?.expertise || []).join(' · ')}</p>
                            <dl>
                                <div>
                                    <dt>Última actualización</dt>
                                    <dd>${lastUpdated ? formatDate(lastUpdated, longDate) : '—'}</dd>
                                </div>
                                <div>
                                    <dt>Puntaje</dt>
                                    <dd>${score || '—'}</dd>
                                </div>
                            </dl>
                            <div class="rubric-iterations">
                                ${iterations.length ? iterations.map(iter => `
                                    <div class="rubric-iteration">
                                        <span>${iter.submission ? `Envío ${iter.submission}` : 'Envío'}</span>
                                        <span>${iter.score && iter.score !== '—' ? `Puntaje: ${iter.score}` : ''}</span>
                                        <span>${iter.updated ? formatDate(iter.updated, shortDate) : ''}</span>
                                    </div>
                                    <p class="muted tiny">${iter.summary || 'Sin comentarios.'}</p>
                                `).join('') : '<p class="muted tiny">Sin rúbrica registrada.</p>'}
                            </div>
                        </div>
                        <div class="rubric-actions">
                            <button type="button" class="btn-link rubric-open" data-project="${project.id}" data-reviewer="${reviewerId}">Ver rúbrica</button>
                        </div>
                    `;
                }

                elements.rubricGrid.appendChild(card);
            });

            elements.rubricGrid.querySelectorAll('.rubric-open').forEach(button => {
                button.addEventListener('click', () => {
                    const projectId = button.dataset.project;
                    const reviewerId = button.dataset.reviewer;
                    window.location.href = `./review-session.html?doc=${projectId}&reviewer=${reviewerId}`;
                });
            });
        }

        function renderSubmissions(project) {
            if (!project.submissions || !project.submissions.length) {
                elements.submissionsSection.hidden = true;
                return;
            }
            elements.submissionsSection.hidden = false;
            elements.submissionsGrid.innerHTML = '';
            project.submissions.forEach((submission, index) => {
                const card = document.createElement('article');
                const badgeClass = statusVariant(submission.status);
                card.className = 'submission-card';
                card.innerHTML = `
                    <header>
                        <strong>${submission.label || `Envío ${index + 1}`}</strong>
                        <span class="submission-status ${badgeClass}">${submission.status || 'Sin estado'}</span>
                    </header>
                    <div class="submission-meta">
                        <span>Registrado: ${submission.submitted ? formatDate(submission.submitted, longDate) : '—'}</span>
                        <span>${submission.notes || 'Sin notas adicionales.'}</span>
                    </div>
                `;
                elements.submissionsGrid.appendChild(card);
            });
        }

        function renderApproval(project) {
            if (!elements.approvalSection) return;
            elements.approvalSection.hidden = false;
            const locked = !!project.locked;
            if (locked) {
                elements.approvalNote.textContent = 'Proyecto aprobado y cerrado. No se permiten más cambios.';
                elements.approveBtn.disabled = true;
            } else {
                const pending = getAssigned(project).length < MAX_REVIEWERS;
                elements.approvalNote.textContent = pending
                    ? 'Completa la asignación y rúbricas antes de aprobar.'
                    : 'Cuando todo esté en orden puedes aprobar para cerrar el proyecto.';
                elements.approveBtn.disabled = false;
            }
            elements.approveBtn.onclick = () => approveProject(project.id);
        }

        function approveProject(projectId) {
            const project = getProject(projectId);
            if (!project || project.locked) return;
            project.locked = true;
            project.stage = 'Cerrado';
            project.status = 'Aprobado';
            project.rubric.status = 'Aprobado';
            project.rubric.updated = new Date().toISOString().slice(0, 10);
            project.timeline.unshift({
                type: 'manager',
                message: 'Proyecto aprobado y cerrado',
                at: new Date().toISOString()
            });
            openSlotIndex = null;
            renderAll();
        }

        function renderTimeline(project) {
            elements.timelineSection.hidden = false;
            elements.timelineList.innerHTML = '';
            project.timeline
                .slice()
                .sort((a, b) => new Date(b.at) - new Date(a.at))
                .forEach(entry => {
                    const li = document.createElement('li');
                    li.className = `timeline-item timeline-${entry.type}`;
                    li.innerHTML = `
                        <span class="timeline-meta">${formatDateTime(entry.at)}</span>
                        <p>${entry.message}</p>
                    `;
                    elements.timelineList.appendChild(li);
                });

            if (!project.timeline.length) {
                elements.timelineList.innerHTML = '<li class="timeline-item">Sin registros todavía.</li>';
            }
        }

        function showAssignmentNote(message, isWarning = false) {
            const note = elements.assignmentNote;
            if (!note) return;
            note.dataset.flash = 'true';
            note.textContent = message;
            note.classList.toggle('is-warning', !!isWarning);
            if (message) {
                setTimeout(() => {
                    note.dataset.flash = 'false';
                    note.classList.remove('is-warning');
                    const project = getProject(activeProjectId);
                    if (project) {
                        renderSlots(project);
                    }
                }, 4000);
            }
        }

        /*
        function removeReviewer(projectId, slotIndex) {
            const project = getProject(projectId);
            if (!project || project.locked) return;
            const slots = getSlots(project);
            if (slotIndex < 0 || slotIndex >= MAX_REVIEWERS) return;
            const reviewerId = slots[slotIndex];
            if (!reviewerId) return;
            const reviewer = getReviewer(reviewerId);
            slots[slotIndex] = null;
            openSlotIndex = slotIndex;
            project.timeline.unshift({
                type: 'manager',
                message: `Se liberó a ${reviewer?.name || 'un revisor'} del proyecto`,
                at: new Date().toISOString()
            });
            renderAll();
            showAssignmentNote(`Liberaste el espacio de ${reviewer?.name || 'revisor'}.`, false);
        }*/
        async function removeReviewer(projectId, slotIndex) {
            // 1. Obtenemos el ID del revisor que está en ese espacio (slot)
            const project = getProject(projectId);
            const slots = getSlots(project);
            const reviewerId = slots[slotIndex];

            if (!reviewerId) return; // Si no hay nadie, no hacemos nada

            // 2. Preguntamos confirmación (Opcional, pero recomendado)
            if (!confirm("¿Estás seguro de que deseas eliminar a este revisor? Se perderán sus avances.")) {
                return;
            }

            // 3. Enviamos la orden de borrar al Backend
            try {
                const payload = {
                    idProyecto: projectId,
                    idRevisor: reviewerId
                };

                const response = await fetch('../php/manager_eliminarRevisor.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.success) {
                    // ÉXITO: Limpiamos visualmente y recargamos
                    
                    // Borramos del array local inmediatamente para que se sienta rápido
                    project.slots[slotIndex] = null;
                    delete project.reviews[reviewerId];
                    
                    // Agregamos al historial (timeline) visual
                    project.timeline.unshift({
                        type: 'manager',
                        message: 'Se eliminó un revisor del proyecto',
                        at: new Date().toISOString()
                    });

                    // Recargamos los datos reales de la BD para asegurar que todo esté sincrinizado
                    setActiveProject(projectId);
                    
                    alert("Revisor eliminado correctamente.");
                } else {
                    alert("Error al eliminar: " + data.message);
                }

            } catch (error) {
                console.error("Error de red:", error);
                alert("No se pudo conectar con el servidor.");
            }
        }

        function renderHistory() {
            elements.historyTable.innerHTML = '';
            projects
                .slice()
                .sort((a, b) => new Date(b.submitted) - new Date(a.submitted))
                .forEach(project => {
                    const row = document.createElement('tr');
                    const reviewerNames = getAssigned(project).map(id => getReviewer(id)?.name || '—').join(', ') || 'Sin asignar';
                    row.innerHTML = `
                        <td><code>${project.id}</code></td>
                        <td>
                            <div class="history-project">
                                <strong>${project.title}</strong>
                                <span class="muted small">${project.author}</span>
                            </div>
                        </td>
                        <td><span class="status-pill ${statusClass(project.stage)}">${project.stage}</span></td>
                        <td>${project.rubric.status}${project.rubric.score && project.rubric.score !== '—' ? ` · ${project.rubric.score}` : ''}</td>
                        <td>${reviewerNames}</td>
                        <td>${project.rubric.updated ? formatDate(project.rubric.updated, shortDate) : formatDate(project.submitted, shortDate)}</td>
                    `;
                    elements.historyTable.appendChild(row);
                });
        }

        function updateMetrics() {
            const total = projects.length;
            const open = projects.filter(project => getAssigned(project).length < MAX_REVIEWERS).length;
            const review = projects.filter(project => project.stage.toLowerCase().includes('revisión')).length;
            const completed = projects.filter(project => project.rubric.status.toLowerCase().includes('aceptado') || project.stage.toLowerCase().includes('final')).length;

            elements.metrics.total.textContent = total;
            elements.metrics.updated.textContent = `Actualización: ${formatDate(new Date().toISOString().slice(0, 10), longDate)}`;
            elements.metrics.open.textContent = open;
            elements.metrics.review.textContent = review;
            elements.metrics.completed.textContent = completed;
            if (elements.metrics.completedInfo) {
                elements.metrics.completedInfo.textContent = completed
                    ? `Última rúbrica: ${formatDate(projects.slice().sort((a, b) => new Date(b.rubric.updated || 0) - new Date(a.rubric.updated || 0))[0].rubric.updated || new Date().toISOString().slice(0, 10), shortDate)}`
                    : 'Sin rúbricas finalizadas aún';
            }
        }

        function renderAll() {
            renderProjects();
            renderAssignment();
            //renderHistory();
            //updateMetrics();
        }

        elements.projectFilter.addEventListener('change', event => {
            projectFilter = event.target.value;
            projectPage = 0;
            renderProjects();
        });

        if (elements.projectsPrev) {
            elements.projectsPrev.addEventListener('click', () => {
                if (projectPage > 0) {
                    projectPage -= 1;
                    const startIndex = projectPage * PAGE_SIZE;
                    const nextProject = filteredProjects[startIndex];
                    if (nextProject) {
                        setActiveProject(nextProject.id);
                    } else {
                        renderProjects();
                    }
                }
            });
        }

        if (elements.projectsNext) {
            elements.projectsNext.addEventListener('click', () => {
                const totalPages = filteredProjects.length ? Math.ceil(filteredProjects.length / PAGE_SIZE) : 1;
                if (projectPage < totalPages - 1) {
                    projectPage += 1;
                    const startIndex = projectPage * PAGE_SIZE;
                    const nextProject = filteredProjects[startIndex];
                    if (nextProject) {
                        setActiveProject(nextProject.id);
                    } else {
                        renderProjects();
                    }
                }
            });
        }

        elements.projectSearch.addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                projectQuery = event.target.value.trim().toLowerCase();
                projectPage = 0;
                renderProjects();
            }
        });

        elements.projectSearch.addEventListener('change', event => {
            projectQuery = event.target.value.trim().toLowerCase();
            projectPage = 0;
            renderProjects();
        });

        //renderAll();
        //fetchProjects(); 
        //fetchReviewers();
        async function initManager() {
        console.log("Iniciando sistema...");
        await fetchReviewers(); // 1. Primero revisores
        await fetchProjects();  // 2. Luego proyectos
    }
    initManager();
    })();
    </script>







    <!-- script para ocultar los proyectos -->
    <script>
        const hideButton = document.querySelector('.hide-button');

        function toggleProjects() {
            const projectsList = document.querySelector('.projects-list');
            projectsList.style.display = projectsList.style.display === 'none' ? 'block' : 'none';
            hideButton.textContent = projectsCard.style.display === 'none' ? 'Mostrar' : 'Ocultar';
        }


    </script>
</body>
</html>


